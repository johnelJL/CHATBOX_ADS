generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String    @id @default(cuid())
  name      String?
  email     String?   @unique
  image     String?
  role      String    @default("user")
  listings  Listing[]
  sessions  Session[]
  accounts  Account[]
  chatSessions ChatSession[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

model Listing {
  id              String    @id @default(cuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id])
  status          ListingStatus @default(draft)
  title           String
  description     String
  price           Float
  currency        String   @default("EUR")
  locationCity    String?
  locationRegion  String
  lat             Float?
  lon             Float?
  make            String
  model           String
  trim            String?
  year            Int
  mileageKm       Int
  bodyType        String?
  fuelType        String?
  transmission    String?
  drivetrain      String?
  engineSizeL     Float?
  powerHp         Float?
  doors           Int?
  color           String?
  condition       String? @default("used")
  ownersCount     Int?
  vin             String?
  plateRedacted   Boolean  @default(false)
  serviceHistory  String?
  accidentHistory String?
  photosCount     Int      @default(0)
  extras          String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  images          Image[]
  moderationFlags ModerationFlag[]
  chatSessions    ChatSession[]
}

enum ListingStatus {
  draft
  active
  paused
  flagged
}

model Image {
  id        String   @id @default(cuid())
  listingId String
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)
  url       String
  width     Int
  height    Int
  blurhash  String
  order     Int      @default(0)
}

model ChatSession {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id])
  listingId String?
  listing   Listing?  @relation(fields: [listingId], references: [id], onDelete: SetNull)
  state     ChatState @default(collecting)
  messages  Message[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
}

enum ChatState {
  collecting
  complete
  abandoned
}

model Message {
  id             String   @id @default(cuid())
  chatSessionId  String
  chatSession    ChatSession @relation(fields: [chatSessionId], references: [id], onDelete: Cascade)
  role           MessageRole
  content        String
  toolName       String?
  json           Json?
  createdAt      DateTime @default(now())
}

enum MessageRole {
  user
  assistant
  tool
}

model ModerationFlag {
  id        String   @id @default(cuid())
  listingId String
  listing   Listing @relation(fields: [listingId], references: [id], onDelete: Cascade)
  reason    String
  score     Float
  createdAt DateTime @default(now())
}

model Account {
  id                 String  @id @default(cuid())
  userId             String
  type               String
  provider           String
  providerAccountId  String
  refresh_token      String? @db.Text
  access_token       String? @db.Text
  expires_at         Int?
  token_type         String?
  scope              String?
  id_token           String? @db.Text
  session_state      String?
  oauth_token_secret String?
  oauth_token        String?
  user               User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
